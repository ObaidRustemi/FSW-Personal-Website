<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Rain on Glass ‚Äì Desktop Tech Demo</title>
  <style>
    body { margin: 0; min-height: 200vh; color: #fff; font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background:
        linear-gradient(120deg, #0b1e39, #00152a 60%),
        url('https://images.unsplash.com/photo-1491553895911-0055eca6402d?q=80&w=1600&auto=format&fit=crop') center/cover no-repeat fixed;
    }
    img.bg { position: fixed; inset: 0; width: 100%; height: 100%; object-fit: cover; z-index: 0; }
    .hero { padding: 6rem 4rem; max-width: 60rem; }
    .overlay { position: fixed; inset: 0; background: rgba(12,14,16,0.35);
      backdrop-filter: blur(14px); -webkit-backdrop-filter: blur(14px); pointer-events: none; }
    .overlay.no-backdrop { backdrop-filter: none; -webkit-backdrop-filter: none; background: rgba(12,14,16,0.65);
      background-repeat: no-repeat; background-position: 0 0; background-size: cover; }
    #rainCanvas { position: absolute; inset: 0; pointer-events: none; display: block; }
    .toggle { position: fixed; right: 16px; bottom: 16px; z-index: 2; padding: 10px 14px; border-radius: 8px; border: 0;
      background: #3058ff; color: #fff; cursor: pointer; }
  </style>
</head>
<body>
  <img id="bgImage" class="bg" src="https://res.cloudinary.com/traveltripperweb/image/upload/c_fit,f_auto,h_1200,q_auto,w_1200/v1627681436/bgvlhnmlrwyhm2xwdock.jpg" crossorigin="anonymous" alt="Background" />

  <div class="hero">
    <h1>Rain on Glass ‚Äì Desktop Tech Demo</h1>
    <p>Toggle the overlay. Look for sharper, slightly shifted background inside droplets (refraction), plus rim and streaks.</p>
  </div>

  <div class="overlay" id="overlay">
    <canvas id="rainCanvas"></canvas>
  </div>

  <!-- Rain Control Panel -->
  <div id="rainControls" style="position: fixed; top: 20px; right: 20px; background: rgba(0,0,0,0.8); color: white; padding: 20px; border-radius: 10px; font-family: Arial, sans-serif; min-width: 250px; z-index: 1000;">
    <h3 style="margin: 0 0 15px 0; color: #4dff87;">üåßÔ∏è Rain Controls</h3>
    
    <!-- Play/Pause Button -->
    <div style="margin-bottom: 20px; text-align: center;">
      <button id="playPauseBtn" style="background: #4dff87; color: black; border: none; padding: 10px 20px; border-radius: 5px; font-weight: bold; cursor: pointer; font-size: 14px;">
        ‚è∏Ô∏è Pause Rain
      </button>
    </div>
    
    <!-- Rain Amount -->
    <div style="margin-bottom: 15px;">
      <label style="display: block; margin-bottom: 5px; font-size: 14px;">Rain Amount:</label>
      <input type="range" id="rainAmount" min="0" max="300" value="180" style="width: 100%;">
      <span id="rainAmountValue" style="font-size: 12px; color: #ccc;">180 drops</span>
    </div>
    
    <!-- Rain Speed -->
    <div style="margin-bottom: 15px;">
      <label style="display: block; margin-bottom: 5px; font-size: 14px;">Rain Speed:</label>
      <input type="range" id="rainSpeed" min="0.1" max="1.0" step="0.1" value="0.4" style="width: 100%;">
      <span id="rainSpeedValue" style="font-size: 12px; color: #ccc;">0.4x</span>
    </div>
    
    <!-- Drop Size Variance -->
    <div style="margin-bottom: 15px;">
      <label style="display: block; margin-bottom: 5px; font-size: 14px;">Drop Size Variance:</label>
      <input type="range" id="sizeVariance" min="0.5" max="3.0" step="0.1" value="1.0" style="width: 100%;">
      <span id="sizeVarianceValue" style="font-size: 12px; color: #ccc;">1.0x</span>
    </div>
    
    <!-- Wind Effect -->
    <div style="margin-bottom: 15px;">
      <label style="display: block; margin-bottom: 5px; font-size: 14px;">Wind Effect:</label>
      <input type="range" id="windEffect" min="0" max="0.2" step="0.01" value="0.05" style="width: 100%;">
      <span id="windEffectValue" style="font-size: 12px; color: #ccc;">0.05</span>
    </div>
    
    <!-- Trail Intensity -->
    <div style="margin-bottom: 15px;">
      <label style="display: block; margin-bottom: 5px; font-size: 14px;">Trail Intensity:</label>
      <input type="range" id="trailIntensity" min="0" max="1" step="0.1" value="0.5" style="width: 100%;">
      <span id="trailIntensityValue" style="font-size: 12px; color: #ccc;">0.5</span>
    </div>
    
    <!-- Blur Quality -->
    <div style="margin-bottom: 15px;">
      <label style="display: block; margin-bottom: 5px; font-size: 14px;">Blur Quality:</label>
      <input type="range" id="blurQuality" min="1" max="8" step="1" value="4" style="width: 100%;">
      <span id="blurQualityValue" style="font-size: 12px; color: #ccc;">4 passes</span>
    </div>
    
    <!-- Advanced Physics -->
    <div style="margin-top: 20px; border-top: 1px solid #333; padding-top: 15px;">
      <h4 style="margin: 0 0 10px 0; color: #4dff87; font-size: 14px;">üî¨ Advanced Physics</h4>
      
      <!-- Trail Density -->
      <div style="margin-bottom: 10px;">
        <label style="display: block; margin-bottom: 3px; font-size: 12px;">Trail Density:</label>
        <input type="range" id="trailDensity" min="0" max="0.5" step="0.05" value="0.2" style="width: 100%;">
        <span id="trailDensityValue" style="font-size: 11px; color: #ccc;">0.2</span>
      </div>
      
      <!-- Evaporation Rate -->
      <div style="margin-bottom: 10px;">
        <label style="display: block; margin-bottom: 3px; font-size: 12px;">Evaporation:</label>
        <input type="range" id="evaporate" min="0" max="50" step="5" value="10" style="width: 100%;">
        <span id="evaporateValue" style="font-size: 11px; color: #ccc;">10</span>
      </div>
      
      <!-- Refraction Base -->
      <div style="margin-bottom: 10px;">
        <label style="display: block; margin-bottom: 3px; font-size: 12px;">Refraction Base:</label>
        <input type="range" id="refractBase" min="0.1" max="2.0" step="0.1" value="1.5" style="width: 100%;">
        <span id="refractBaseValue" style="font-size: 11px; color: #ccc;">1.5</span>
      </div>
      
      <!-- Refraction Scale -->
      <div style="margin-bottom: 10px;">
        <label style="display: block; margin-bottom: 3px; font-size: 12px;">Refraction Scale:</label>
        <input type="range" id="refractScale" min="0.1" max="3.0" step="0.1" value="2.0" style="width: 100%;">
        <span id="refractScaleValue" style="font-size: 11px; color: #ccc;">2.0</span>
      </div>
    </div>
    
    <!-- Preset Buttons -->
    <div style="margin-top: 20px;">
      <button id="lightRain" style="background: #4dff87; color: black; border: none; padding: 8px 12px; margin: 2px; border-radius: 4px; cursor: pointer; font-size: 12px;">Light Rain</button>
      <button id="heavyRain" style="background: #4dff87; color: black; border: none; padding: 8px 12px; margin: 2px; border-radius: 4px; cursor: pointer; font-size: 12px;">Heavy Rain</button>
      <button id="storm" style="background: #4dff87; color: black; border: none; padding: 8px 12px; margin: 2px; border-radius: 4px; cursor: pointer; font-size: 12px;">Storm</button>
    </div>
    
    <!-- Toggle Controls -->
    <div style="margin-top: 15px; border-top: 1px solid #333; padding-top: 15px;">
      <label style="display: flex; align-items: center; margin-bottom: 10px; font-size: 14px;">
        <input type="checkbox" id="enableTrails" checked style="margin-right: 8px;">
        Enable Trails
      </label>
      <label style="display: flex; align-items: center; margin-bottom: 10px; font-size: 14px;">
        <input type="checkbox" id="enableCondensation" checked style="margin-right: 8px;">
        Enable Condensation
      </label>
      <label style="display: flex; align-items: center; font-size: 14px;">
        <input type="checkbox" id="enableCollisions" checked style="margin-right: 8px;">
        Enable Collisions
      </label>
    </div>
  </div>

  <script src="https://unpkg.com/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script src="rain-utils.js"></script>
    <script src="rain-on-glass.js"></script>
  <script>
  (function(){
    const canvas = document.getElementById('rainCanvas');
    const bgImg = document.getElementById('bgImage');
    function size(){
      const dpr = Math.min(window.devicePixelRatio||1, 2);
      const W = Math.max(1, Math.floor(window.innerWidth));
      const H = Math.max(1, Math.floor(window.innerHeight));
      canvas.width = Math.round(W*dpr);
      canvas.height = Math.round(H*dpr);
      canvas.style.width = W+'px';
      canvas.style.height = H+'px';
    }
    window.addEventListener('resize', size);
    window.addEventListener('load', async () => {
      size();
      const rain = new RainOnGlass(canvas, {
        standalone: true,
        backgroundSource: '#bgImage',
        blur: 8,
        gravityDeg: 90,
        gravity: 0.4, // Reduced gravity for slower fall
        collisions: true,
        smudge: true,
        fps: 60,
        maxDrops: 180,
        useMiniRefraction: true,
        miniBoost: true,
        condensation: true,
        condensationDensity: 0.8, // Increased for dense coverage like reference
        condensationSize: 1.2,    // Larger micro-droplets
        condensationSparkle: 0.9, // More sparkle
        // Enhanced realistic physics
        enableTrails: true,
        dragCoeff: 0.8,
        windX: 0.05,  // Even more reduced wind for more vertical trails
        windY: 0,
        adhesionBase: 0.95, // Increased stickiness
        slideThreshold: 8,
        terminalVelocity: 15
      });
      await rain.captureBackground();
      rain.start();
      window.__demo = rain;
      
             // Add debug functions to window for testing
             window.testRain = {
               getDropCount: () => rain.drops.length,
               getCondensationCount: () => rain.condensation.length,
               addDrop: (x, y, r) => rain.spawn(x, y, r),
               clearDrops: () => { rain.drops = []; rain.condensation = []; },
               restart: async () => {
                 rain.stop();
                 await rain.captureBackground();
                 rain.start();
               },
               play: () => rain.resume(),
               pause: () => rain.pause(),
               toggle: () => {
                 if (rain.running) {
                   rain.pause();
                   console.log('Rain paused (frozen in place)');
                 } else {
                   rain.resume();
                   console.log('Rain resumed');
                 }
               },
               logState: () => {
                 console.log('Rain State:', {
                   drops: rain.drops.length,
                   condensation: rain.condensation.length,
                   running: rain.running,
                   hasBackground: rain.hasBackground,
                   enableTrails: rain.enableTrails,
                   enableCondensation: rain.enableCondensation
                 });
               },
               testDropMovement: () => {
                 if (rain.drops.length === 0) {
                   console.log('No drops to test movement');
                   return;
                 }
                 
                 const testDrop = rain.drops[0];
                 const initialY = testDrop.y;
                 
                 console.log('Testing drop movement...');
                 console.log('Initial position:', { x: testDrop.x, y: initialY });
                 console.log('Initial velocity:', { vx: testDrop.vx, vy: testDrop.vy });
                 console.log('Mass:', testDrop.mass);
                 console.log('Resistance:', testDrop.resistance);
                 console.log('Shifting:', testDrop.shifting);
                 
                 // Wait 1 second and check position
                 setTimeout(() => {
                   const finalY = testDrop.y;
                   const moved = Math.abs(finalY - initialY) > 1;
                   console.log('After 1 second:');
                   console.log('Final position:', { x: testDrop.x, y: finalY });
                   console.log('Final velocity:', { vx: testDrop.vx, vy: testDrop.vy });
                   console.log('Movement detected:', moved, 'Distance moved:', Math.abs(finalY - initialY));
                   
                   if (!moved) {
                     console.warn('‚ö†Ô∏è DROP NOT MOVING - Physics may be broken!');
                   } else {
                     console.log('‚úÖ Drop is moving correctly');
                   }
                 }, 1000);
               },
               runComprehensiveTests: () => {
                 console.log('üß™ RUNNING COMPREHENSIVE RAIN SYSTEM TESTS');
                 console.log('==========================================');
                 
                 // Test 1: Basic System State
                 console.log('\nüìä Test 1: Basic System State');
                 console.log('Running:', rain.running);
                 console.log('Has Background:', rain.hasBackground);
                 console.log('Canvas Size:', { width: rain.canvas.width, height: rain.canvas.height });
                 console.log('DPR:', rain.dpr);
                 
                 // Test 2: Physics Configuration
                 console.log('\n‚öôÔ∏è Test 2: Physics Configuration');
                 console.log('Gravity Base:', rain.gravityBase);
                 console.log('FPS:', rain.fps);
                 console.log('Evaporate:', rain.evaporate);
                 console.log('Wind X/Y:', rain.windX, rain.windY);
                 
                 // Test 3: Drop Properties
                 console.log('\nüíß Test 3: Drop Properties');
                 if (rain.drops.length > 0) {
                   const drop = rain.drops[0];
                   console.log('First Drop Properties:');
                   console.log('- Position:', { x: drop.x, y: drop.y });
                   console.log('- Velocity:', { vx: drop.vx, vy: drop.vy });
                   console.log('- Mass:', drop.mass);
                   console.log('- Radius:', drop.r);
                   console.log('- Resistance:', drop.resistance);
                   console.log('- Shifting:', drop.shifting);
                   console.log('- Dead:', drop._dead);
                   console.log('- Spread:', drop.spread);
                 } else {
                   console.log('No drops found!');
                 }
                 
                 // Test 4: Control Panel Values
                 console.log('\nüéõÔ∏è Test 4: Control Panel Values');
                 const controls = {
                   rainAmount: document.getElementById('rainAmount')?.value,
                   rainSpeed: document.getElementById('rainSpeed')?.value,
                   sizeVariance: document.getElementById('sizeVariance')?.value,
                   windEffect: document.getElementById('windEffect')?.value,
                   trailIntensity: document.getElementById('trailIntensity')?.value,
                   blurQuality: document.getElementById('blurQuality')?.value
                 };
                 console.log('Slider Values:', controls);
                 
                 // Test 5: Physics Calculation Test
                 console.log('\nüî¨ Test 5: Physics Calculation Test');
                 if (rain.drops.length > 0) {
                   const drop = rain.drops[0];
                   const dtScale = 0.016; // Simulate dtScale
                   
                   console.log('Simulating physics calculation:');
                   console.log('- Force = gravityBase * mass - resistance');
                   console.log('- Force =', rain.gravityBase, '*', drop.mass, '-', drop.resistance, '=', rain.gravityBase * drop.mass - drop.resistance);
                   
                   const force = rain.gravityBase * drop.mass - drop.resistance;
                   const acceleration = force / drop.mass;
                   
                   console.log('- Acceleration = force / mass =', force, '/', drop.mass, '=', acceleration);
                   console.log('- Is Finite?', isFinite(force), isFinite(acceleration));
                 }
                 
                 // Test 6: Movement Test
                 console.log('\nüèÉ Test 6: Movement Test');
                 if (rain.drops.length > 0) {
                   const drop = rain.drops[0];
                   const initialPos = { x: drop.x, y: drop.y };
                   
                   setTimeout(() => {
                     const finalPos = { x: drop.x, y: drop.y };
                     const moved = Math.abs(finalPos.y - initialPos.y) > 1;
                     console.log('Initial Position:', initialPos);
                     console.log('Final Position:', finalPos);
                     console.log('Movement Detected:', moved);
                     console.log('Distance Moved:', Math.abs(finalPos.y - initialPos.y));
                   }, 1000);
                 }
                 
                 console.log('\n‚úÖ Tests completed. Check results above.');
               },
               testSliderControls: () => {
                 console.log('üéõÔ∏è TESTING SLIDER CONTROLS');
                 console.log('==========================');
                 
                 const sliders = [
                   'rainAmount', 'rainSpeed', 'sizeVariance', 
                   'windEffect', 'trailIntensity', 'blurQuality'
                 ];
                 
                 sliders.forEach(sliderId => {
                   const slider = document.getElementById(sliderId);
                   if (slider) {
                     console.log(`${sliderId}:`, {
                       value: slider.value,
                       min: slider.min,
                       max: slider.max,
                       step: slider.step,
                       disabled: slider.disabled
                     });
                   } else {
                     console.error(`‚ùå Slider ${sliderId} not found!`);
                   }
                 });
                 
                 // Test if controls are connected
                 console.log('\nüîó Testing Control Connections:');
                 console.log('Rain object properties:');
                 console.log('- maxDrops:', rain.maxDrops);
                 console.log('- gravityBase:', rain.gravityBase);
                 console.log('- sizeVariance:', rain.sizeVariance);
                 console.log('- windX:', rain.windX);
                 console.log('- trailIntensity:', rain.trailIntensity);
                 console.log('- blurIterations:', rain.blurIterations);
               },
               testSimplePhysics: () => {
                 console.log('üî¨ TESTING SIMPLE PHYSICS');
                 console.log('=========================');
                 
                 if (rain.drops.length === 0) {
                   console.log('No drops to test. Adding a test drop...');
                   rain.spawn(100, 50, 10);
                 }
                 
                 const drop = rain.drops[0];
                 console.log('Test Drop Initial State:');
                 console.log('- Position:', { x: drop.x, y: drop.y });
                 console.log('- Velocity:', { vx: drop.vx, vy: drop.vy });
                 console.log('- Mass:', drop.mass);
                 console.log('- Radius:', drop.r);
                 
                 // Test simple gravity calculation
                 const simpleGravity = rain.gravityBase * (drop.r / 25);
                 console.log('\nSimple Gravity Test:');
                 console.log('- Gravity Base:', rain.gravityBase);
                 console.log('- Drop Radius:', drop.r);
                 console.log('- Simple Gravity Force:', simpleGravity);
                 
                 // Test current complex physics
                 const complexForce = rain.gravityBase * drop.mass - drop.resistance;
                 const complexAcceleration = complexForce / drop.mass;
                 console.log('\nComplex Physics Test:');
                 console.log('- Complex Force:', complexForce);
                 console.log('- Complex Acceleration:', complexAcceleration);
                 console.log('- Is Finite?', isFinite(complexForce), isFinite(complexAcceleration));
                 
                 // Test which one makes more sense
                 console.log('\nComparison:');
                 console.log('- Simple gravity would add:', simpleGravity, 'to vy per frame');
                 console.log('- Complex physics would add:', complexAcceleration, 'to vy per frame');
               },
               resetToSimplePhysics: () => {
                 console.log('üîÑ RESETTING TO SIMPLE PHYSICS');
                 console.log('==============================');
                 
                 // Clear all drops
                 rain.drops = [];
                 rain.condensation = [];
                 
                 // Reset physics to simple system
                 rain.gravityBase = 0.6; // Reset to working value
                 rain.evaporate = 0; // Disable evaporation for testing
                 
                 console.log('Physics reset. Adding test drops...');
                 
                 // Add some test drops
                 for (let i = 0; i < 5; i++) {
                   rain.spawn(100 + i * 50, 50, 8 + Math.random() * 4);
                 }
                 
                 console.log('Added 5 test drops. Check if they fall now.');
               },
               testRefraction: () => {
                 console.log('üîç TESTING REFRACTION SYSTEM');
                 console.log('============================');
                 
                 if (rain.drops.length === 0) {
                   console.log('No drops to test. Adding a test drop...');
                   rain.spawn(200, 200, 15); // Large drop for testing
                 }
                 
                 const drop = rain.drops[0];
                 console.log('Test Drop for Refraction:');
                 console.log('- Position:', { x: drop.x, y: drop.y });
                 console.log('- Radius:', drop.r);
                 console.log('- Has Background:', rain.hasBackground);
                 console.log('- Background Size:', { width: rain.bgSharp.width, height: rain.bgSharp.height });
                 
                 // Test refraction parameters
                 console.log('\nRefraction Parameters:');
                 console.log('- Refract Base:', rain.refractBase);
                 console.log('- Refract Scale:', rain.refractScale);
                 console.log('- Use Mini Refraction:', rain.useMiniRefraction);
                 console.log('- Mini Boost:', rain.miniBoost);
                 
                 // Test sampling area calculation
                 const rx = (drop.r * 0.92) / rain.dpr;
                 const ry = (drop.r * 0.92) / rain.dpr;
                 const sizeFactor = Math.min(1, rx / 8);
                 const baseOffsetX = rx * rain.refractBase * 0.15 * sizeFactor;
                 const baseOffsetY = -ry * (rain.refractBase * 0.1) * sizeFactor;
                 
                 console.log('\nSampling Area Calculation:');
                 console.log('- Drop Radius (rx):', rx);
                 console.log('- Drop Radius (ry):', ry);
                 console.log('- Size Factor:', sizeFactor);
                 console.log('- Offset X:', baseOffsetX);
                 console.log('- Offset Y:', baseOffsetY);
                 
                 const sx = Math.max(0, Math.min(rain.bgSharp.width - rx * 2 * rain.dpr, (drop.x - rx + baseOffsetX) * rain.dpr));
                 const sy = Math.max(0, Math.min(rain.bgSharp.height - ry * 2 * rain.dpr, (drop.y - ry + baseOffsetY) * rain.dpr));
                 const sw = Math.min(rx * 2 * rain.dpr, rain.bgSharp.width - sx);
                 const sh = Math.min(ry * 2 * rain.dpr, rain.bgSharp.height - sy);
                 
                 console.log('\nSource Rectangle (THIS IS THE SQUARE!):');
                 console.log('- Source X:', sx);
                 console.log('- Source Y:', sy);
                 console.log('- Source Width:', sw);
                 console.log('- Source Height:', sh);
                 console.log('- Aspect Ratio:', sw / sh);
                 
                 console.log('\nüéØ DIAGNOSIS: The square comes from sampling a rectangular area!');
                 console.log('We need to implement circular sampling or radial distortion.');
               },
               testCircularRefraction: () => {
                 console.log('üîÑ TESTING CIRCULAR REFRACTION APPROACH');
                 console.log('=======================================');
                 
                 // Create a test canvas to demonstrate circular sampling
                 const testCanvas = document.createElement('canvas');
                 testCanvas.width = 100;
                 testCanvas.height = 100;
                 const testCtx = testCanvas.getContext('2d');
                 
                 // Draw a test pattern
                 testCtx.fillStyle = 'red';
                 testCtx.fillRect(0, 0, 50, 50);
                 testCtx.fillStyle = 'blue';
                 testCtx.fillRect(50, 0, 50, 50);
                 testCtx.fillStyle = 'green';
                 testCtx.fillRect(0, 50, 50, 50);
                 testCtx.fillStyle = 'yellow';
                 testCtx.fillRect(50, 50, 50, 50);
                 
                 console.log('Created test pattern with 4 colored squares');
                 console.log('Current approach: Samples rectangular area (creates square)');
                 console.log('Better approach: Use radial sampling or distortion');
                 
                 // Show the test canvas
                 document.body.appendChild(testCanvas);
                 testCanvas.style.position = 'fixed';
                 testCanvas.style.top = '10px';
                 testCanvas.style.left = '10px';
                 testCanvas.style.border = '2px solid white';
                 testCanvas.style.zIndex = '9999';
                 
                 console.log('Test canvas added to page. This shows the square sampling problem.');
                 
                 // Clean up after 5 seconds
                 setTimeout(() => {
                   document.body.removeChild(testCanvas);
                   console.log('Test canvas removed.');
                 }, 5000);
               },
               testRefractionFix: () => {
                 console.log('üîß TESTING REFRACTION FIX');
                 console.log('=========================');
                 
                 if (rain.drops.length === 0) {
                   console.log('No drops to test. Adding a test drop...');
                   rain.spawn(200, 200, 15); // Large drop for testing
                 }
                 
                 const drop = rain.drops[0];
                 console.log('Testing Fixed Refraction:');
                 console.log('- Drop Position:', { x: drop.x, y: drop.y });
                 console.log('- Drop Radius:', drop.r);
                 
                 // Test the new circular approach
                 const rx = (drop.r * 0.92) / rain.dpr;
                 const ry = (drop.r * 0.92) / rain.dpr;
                 
                 console.log('\nNew Circular Approach:');
                 console.log('- Uses ctx.arc() for perfect circular mask');
                 console.log('- No more rectangular sampling!');
                 console.log('- Clean, simple refraction like reference images');
                 
                 console.log('\n‚úÖ EXPECTED RESULT:');
                 console.log('- Perfect circular droplets (no squares)');
                 console.log('- Clean background magnification');
                 console.log('- Realistic water droplet lens effect');
                 
                 console.log('\nüéØ REFRESH THE PAGE to see the fix!');
               },
               testSquareSamplingBug: () => {
                 console.log('üö® CRITICAL BUG: SQUARE SAMPLING STILL EXISTS');
                 console.log('==============================================');
                 
                 console.log('‚ùå ROOT CAUSE IDENTIFIED:');
                 console.log('- We added circular MASKING (ctx.arc + ctx.clip)');
                 console.log('- But we still use RECTANGULAR SAMPLING (sx, sy, sw, sh)');
                 console.log('- The square content is still there, just clipped to a circle!');
                 
                 console.log('\nüîç EVIDENCE:');
                 console.log('- Line 1251-1254: Still calculating rectangular source area');
                 console.log('- Line 1274: Still using ctx.drawImage(srcCanvas, sx, sy, sw, sh, ...)');
                 console.log('- The circular mask just hides the square edges, content is still square!');
                 
                 console.log('\n‚úÖ REQUIRED FIX:');
                 console.log('- Replace rectangular sampling with radial/circular sampling');
                 console.log('- OR use multiple small samples in a circular pattern');
                 console.log('- OR implement proper radial distortion algorithm');
                 
                 console.log('\nüéØ This explains why user still sees squares!');
               },
               testRadialSamplingFix: () => {
                 console.log('‚úÖ TESTING PROPER RADIAL SAMPLING FIX');
                 console.log('====================================');
                 
                 console.log('üîß IMPLEMENTED FIX:');
                 console.log('- Proper radial sampling with magnified background content');
                 console.log('- Larger sampling area (1.5x radius) to capture background');
                 console.log('- Magnification effect like real water droplet lens');
                 console.log('- Circular masking for organic droplet shape');
                 
                 console.log('\nüéØ EXPECTED RESULT:');
                 console.log('- Visible background content through droplets (like reference)');
                 console.log('- Magnified, distorted background (lens effect)');
                 console.log('- NO MORE SQUARES - proper circular refraction');
                 console.log('- Realistic water droplet lens effect');
                 
                 console.log('\nüöÄ REFRESH THE PAGE to see the REAL fix!');
                 
                 return 'Test completed - should now see background through droplets like reference';
               },
               testRainUtils: () => {
                 console.log('üß™ TESTING RAIN UTILITIES');
                 console.log('=========================');
                 
                 if (typeof window.RainUtils === 'undefined') {
                   console.log('‚ùå RainUtils not loaded!');
                   return 'FAILED: RainUtils not available';
                 }
                 
                 console.log('‚úÖ RainUtils loaded successfully!');
                 
                 // Test jittered values
                 const jitteredSize = window.RainUtils.randomJittered(
                   new window.RainUtils.JitterOption(8, 2)
                 );
                 console.log('Jittered size (8¬±2):', jitteredSize);
                 
                 // Test random in rect
                 const rect = new window.RainUtils.Rect(0, 0, 100, 50);
                 const randomPos = window.RainUtils.randomInRect(rect);
                 console.log('Random position in rect:', randomPos);
                 
                 // Test gold noise
                 const noise = window.RainUtils.goldNoise(
                   new window.RainUtils.Vec2(10, 20), 12345
                 );
                 console.log('Gold noise value:', noise);
                 
                 // Test organic variations
                 const naturalSize = window.RainUtils.naturalDropSize(8, 0.3);
                 const naturalSpeed = window.RainUtils.naturalDropSpeed(0.4, 0.2);
                 console.log('Natural drop size:', naturalSize);
                 console.log('Natural drop speed:', naturalSpeed);
                 
                 console.log('\nüéØ All utilities working! Ready for organic enhancements.');
                 
                 return 'SUCCESS: All rain utilities tested and working';
               },
               testOrganicEnhancements: () => {
                 console.log('üåø TESTING ORGANIC ENHANCEMENTS');
                 console.log('===============================');
                 
                 if (rain.drops.length === 0) {
                   console.log('No drops to test. Adding test drops...');
                   for (let i = 0; i < 5; i++) {
                     rain.spawn();
                   }
                 }
                 
                 console.log('‚úÖ Testing organic drop properties:');
                 
                 rain.drops.slice(0, 3).forEach((drop, i) => {
                   console.log(`\nDrop ${i + 1}:`);
                   console.log('- Size:', drop.r.toFixed(2));
                   console.log('- Position:', { x: drop.x.toFixed(2), y: drop.y.toFixed(2) });
                   console.log('- Velocity:', { vx: drop.vx.toFixed(3), vy: drop.vy.toFixed(3) });
                   console.log('- Adhesion:', drop.stick.toFixed(3));
                   console.log('- Density:', drop.density.toFixed(3));
                   console.log('- Trail Distance:', drop.nextTrailDistance.toFixed(1));
                   console.log('- Organic Seed:', drop._organicSeed);
                 });
                 
                 console.log('\nüéØ EXPECTED IMPROVEMENTS:');
                 console.log('- More natural size distribution');
                 console.log('- Organic positioning patterns');
                 console.log('- Natural velocity variations');
                 console.log('- Varied adhesion properties');
                 console.log('- Organic trail spacing');
                 
                 console.log('\nüöÄ REFRESH to see organic enhancements in action!');
                 
                 return 'SUCCESS: Organic enhancements applied to drop spawning';
               },
               testPositionDependentRefraction: () => {
                 console.log('üéØ TESTING POSITION-DEPENDENT REFRACTION');
                 console.log('=======================================');
                 
                 if (rain.drops.length === 0) {
                   console.log('No drops to test. Adding test drops...');
                   for (let i = 0; i < 5; i++) {
                     rain.spawn(100 + i * 100, 100 + i * 50, 10);
                   }
                 }
                 
                 console.log('‚úÖ Testing position-dependent background sampling:');
                 
                 rain.drops.slice(0, 3).forEach((drop, i) => {
                   console.log(`\nDrop ${i + 1} at position (${drop.x.toFixed(1)}, ${drop.y.toFixed(1)}):`);
                   
                   // Calculate position-dependent offsets
                   const positionOffsetX = Math.sin(drop.x * 0.01) * 0.3;
                   const positionOffsetY = Math.cos(drop.y * 0.008) * 0.2;
                   
                   console.log('- Position offset X:', positionOffsetX.toFixed(3));
                   console.log('- Position offset Y:', positionOffsetY.toFixed(3));
                   console.log('- Organic seed:', drop._organicSeed);
                   
                   // Test organic shape variation
                   if (window.RainUtils) {
                     const shapeVariation = window.RainUtils.organicShapeVariation(
                       new window.RainUtils.Vec2(drop.x, drop.y), 
                       drop._organicSeed
                     );
                     console.log('- Shape variation factor:', shapeVariation.toFixed(3));
                   }
                 });
                 
                 console.log('\nüéØ EXPECTED IMPROVEMENTS:');
                 console.log('- Each drop samples different background content');
                 console.log('- Position-dependent refraction offsets');
                 console.log('- Organic elliptical shapes (not perfect circles)');
                 console.log('- Natural shape variations using goldNoise');
                 
                 console.log('\nüöÄ REFRESH to see position-dependent refraction!');
                 
                 return 'SUCCESS: Position-dependent refraction implemented';
               },
               testBackgroundSampling: () => {
                 console.log('üñºÔ∏è TESTING BACKGROUND SAMPLING');
                 console.log('==============================');
                 
                 console.log('‚úÖ Background sampling status:');
                 console.log('- Has background:', rain.hasBackground);
                 console.log('- Background size:', { width: rain.bgSharp.width, height: rain.bgSharp.height });
                 console.log('- Refraction base:', rain.refractBase);
                 console.log('- Refraction scale:', rain.refractScale);
                 
                 if (rain.drops.length === 0) {
                   console.log('No drops to test. Adding test drops...');
                   for (let i = 0; i < 3; i++) {
                     rain.spawn(200 + i * 100, 200 + i * 50, 15);
                   }
                 }
                 
                 console.log('\nüéØ BACKGROUND SAMPLING SHOULD NOW BE VISIBLE:');
                 console.log('- Each drop should show magnified background content');
                 console.log('- Different drops should show different background areas');
                 console.log('- Background should be distorted/magnified through each drop');
                 console.log('- Increased refraction intensity for better visibility');
                 
                 console.log('\nüöÄ REFRESH to see background sampling restored!');
                 
                 return 'SUCCESS: Background sampling restored with increased intensity';
               },
               testVisualRefraction: () => {
                 console.log('üîç VISUAL REFRACTION TEST');
                 console.log('========================');
                 
                 // DISABLE normal rain generation during test
                 rain.testMode = true;
                 
                 // Clear existing drops and condensation to remove white streaks
                 rain.drops.length = 0;
                 rain.condensation.length = 0;
                 
                 // ENSURE RAIN IS RUNNING
                 if (!rain.running) {
                   rain.start();
                 }
                 
                 // WATCHDOG: Monitor drops array for unexpected clearing
                 let lastDropCount = rain.drops.length;
                 const watchdog = setInterval(() => {
                   if (rain.drops.length !== lastDropCount) {
                     console.log(`üö® DROPS ARRAY CHANGED: ${lastDropCount} ‚Üí ${rain.drops.length}`);
                     if (rain.drops.length === 0) {
                       console.log('üö® DROPS ARRAY CLEARED! Investigating...');
                       console.trace('Array cleared at:');
                     }
                     lastDropCount = rain.drops.length;
                   }
                 }, 100);
                 
                 // Store watchdog for cleanup
                 rain._testWatchdog = watchdog;
                 
                 // IMMEDIATE CHECK: Verify drops were actually added
                 setTimeout(() => {
                   console.log('üîç POST-ADDITION CHECK:');
                   console.log('- Drops count:', rain.drops.length);
                   console.log('- First drop _testDrop:', rain.drops[0]?._testDrop);
                   if (rain.drops.length === 0) {
                     console.log('üö® DROPS WERE CLEARED IMMEDIATELY AFTER ADDITION!');
                     console.log('üîç Checking if rain is running:', rain.running);
                     console.log('üîç Checking testMode:', rain.testMode);
                   }
                 }, 50);
                 
                 // Add HUGE, SLOW test drops with ALL required physics properties
                 for (let i = 0; i < 5; i++) {
                   const testDrop = {
                     x: 200 + i * 150, // Spread them out more
                     y: 100 + i * 80,  // Start higher up
                     r: 60, // HUGE radius (3x bigger than normal)
                     vx: 0,
                     vy: 0.1, // VERY SLOW fall speed (normal is 0.5-2.0)
                     stretch: 1,
                     stick: 0.1,
                     mass: 1, // Add mass to prevent NaN
                     density: 1, // Add density
                     label: true, // Force label to show
                     _testDrop: true, // Mark as test drop
                     _organicSeed: 12345 + i,
                     // ADD ALL MISSING PROPERTIES TO PREVENT REMOVAL
                     prevX: 200 + i * 150, // Previous position
                     prevY: 100 + i * 80,  // Previous position
                     age: 0, // Drop age
                     trailDropDensity: 0.2,
                     trailDistance: 0,
                     trailDropSize: 0.1,
                     trailSpread: 0.1,
                     motionInterval: 0,
                     velocitySpread: 0,
                     xShifting: 0,
                     evaporate: 0,
                     shrinkRate: 0,
                     slipRate: 0,
                     spread: { x: 0, y: 0 },
                     resistance: 0.1,
                     shifting: 0,
                     lastTrailPos: { x: 200 + i * 150, y: 100 + i * 80 },
                     nextTrailDistance: 0,
                     nextRandomTime: 0
                   };
                   rain.drops.push(testDrop);
                 }
                 
                 console.log('‚úÖ Added 5 HUGE, SLOW test drops with ROYAL BLUE refraction');
                 console.log('üéØ Look for MASSIVE SOLID ROYAL BLUE drops on screen');
                 
                 return 'Test drops added - check visual result';
               },
               testSimpleRoyalBlue: () => {
                 console.log('üîµ SIMPLE ROYAL BLUE TEST');
                 console.log('========================');
                 
                 // Clear everything and draw simple royal blue circles
                 rain.drops = [];
                 rain.testMode = true;
                 
                 // VERIFY testMode is set
                 console.log('üîç testMode value:', rain.testMode);
                 console.log('üîç !testMode value:', !rain.testMode);
                 
                 // Draw 5 simple royal blue circles directly on canvas
                 const ctx = rain.ctx;
                 ctx.save();
                 
                 for (let i = 0; i < 5; i++) {
                   const x = 200 + i * 150;
                   const y = 200 + i * 50;
                   const r = 60;
                   
                   ctx.fillStyle = 'royalblue';
                   ctx.beginPath();
                   ctx.arc(x, y, r, 0, Math.PI * 2);
                   ctx.fill();
                   
                   console.log(`‚úÖ Drew royal blue circle ${i} at (${x}, ${y})`);
                 }
                 
                 ctx.restore();
                 console.log('üéØ Look for 5 ROYAL BLUE CIRCLES on screen');
                 
                 return 'Simple royal blue test complete';
               },
               debugDropValidation: () => {
                 console.log('üîç DEBUGGING DROP VALIDATION');
                 console.log('============================');
                 
                 // Check current drops array
                 console.log('Current drops count:', rain.drops.length);
                 
                 // Check each drop's validation
                 rain.drops.forEach((drop, index) => {
                   console.log(`Drop ${index}:`, {
                     r: drop.r,
                     x: drop.x,
                     y: drop.y,
                     _testDrop: drop._testDrop,
                     isValidRadius: drop.r && drop.r > 0 && isFinite(drop.r),
                     isValidPosition: isFinite(drop.x) && isFinite(drop.y),
                     rx: drop.r ? Math.max(0.1, (drop.r * 0.92) / rain.dpr) : 'N/A',
                     ry: drop.r ? Math.max(0.1, (drop.r * 0.92) / rain.dpr) : 'N/A'
                   });
                 });
                 
                 // Test validation logic
                 console.log('\nüß™ Testing validation logic:');
                 const testDrop = { r: 60, x: 200, y: 100, _testDrop: true };
                 console.log('Test drop validation:', {
                   radiusCheck: testDrop.r && testDrop.r > 0 && isFinite(testDrop.r),
                   positionCheck: isFinite(testDrop.x) && isFinite(testDrop.y),
                   rxCheck: Math.max(0.1, (testDrop.r * 0.92) / rain.dpr),
                   ryCheck: Math.max(0.1, (testDrop.r * 0.92) / rain.dpr)
                 });
                 
                 return 'Drop validation debug complete';
               },
               disableTestMode: () => {
                 rain.testMode = false;
                 if (rain._testWatchdog) {
                   clearInterval(rain._testWatchdog);
                   rain._testWatchdog = null;
                 }
                 return 'Test mode disabled';
               },
               testNormalRain: () => {
                 console.log('üåßÔ∏è TESTING NORMAL RAIN WORKFLOW');
                 console.log('===============================');
                 
                 // Disable test mode
                 rain.testMode = false;
                 console.log('‚úÖ testMode set to false');
                 
                 // Clear test drops and add normal rain
                 rain.drops = [];
                 for (let i = 0; i < 10; i++) {
                   rain.spawn();
                 }
                 
                 console.log('‚úÖ Added 10 normal rain drops');
                 console.log('üîç Refraction Base:', rain.refractBase);
                 console.log('üîç Refraction Scale:', rain.refractScale);
                 console.log('üéØ Normal rain should be visible');
                 
                 return 'Normal rain test complete';
               },
               debugRefractionCode: () => {
                 console.log('üêõ DEBUGGING REFRACTION CODE');
                 console.log('============================');
                 
                 // Check if our refraction code is being called
                 console.log('‚úÖ Checking refraction parameters:');
                 console.log('- refractBase:', rain.refractBase);
                 console.log('- refractScale:', rain.refractScale);
                 console.log('- hasBackground:', rain.hasBackground);
                 
                 // Check if background canvas exists
                 if (rain.bgSharp) {
                   console.log('- bgSharp canvas exists:', rain.bgSharp.width, 'x', rain.bgSharp.height);
                 } else {
                   console.log('- ‚ùå bgSharp canvas missing!');
                 }
                 
                 // Check if our enhanced spawn function is being used
                 console.log('\nüîç Testing spawn function:');
                 const originalSpawn = rain.spawn;
                 let spawnCallCount = 0;
                 rain.spawn = function(...args) {
                   spawnCallCount++;
                   console.log(`Spawn call #${spawnCallCount}:`, args);
                   return originalSpawn.apply(this, args);
                 };
                 
                 // Test spawn
                 rain.spawn(300, 300, 15);
                 
                 // Restore original spawn
                 rain.spawn = originalSpawn;
                 
                 console.log('\nüéØ If you see spawn calls above, our enhanced spawn is working');
                 
                 return 'Debug complete - check console for spawn calls';
               }
             };
      
      console.log('Rain demo initialized. Use window.testRain for debugging.');
      
      // Rain Control Panel Functionality
      const controls = {
        playPauseBtn: document.getElementById('playPauseBtn'),
        rainAmount: document.getElementById('rainAmount'),
        rainSpeed: document.getElementById('rainSpeed'),
        sizeVariance: document.getElementById('sizeVariance'),
        windEffect: document.getElementById('windEffect'),
        trailIntensity: document.getElementById('trailIntensity'),
        blurQuality: document.getElementById('blurQuality'),
        trailDensity: document.getElementById('trailDensity'),
        evaporate: document.getElementById('evaporate'),
        refractBase: document.getElementById('refractBase'),
        refractScale: document.getElementById('refractScale'),
        enableTrails: document.getElementById('enableTrails'),
        enableCondensation: document.getElementById('enableCondensation'),
        enableCollisions: document.getElementById('enableCollisions'),
        lightRain: document.getElementById('lightRain'),
        heavyRain: document.getElementById('heavyRain'),
        storm: document.getElementById('storm')
      };
      
      const valueDisplays = {
        rainAmount: document.getElementById('rainAmountValue'),
        rainSpeed: document.getElementById('rainSpeedValue'),
        sizeVariance: document.getElementById('sizeVarianceValue'),
        windEffect: document.getElementById('windEffectValue'),
        trailIntensity: document.getElementById('trailIntensityValue'),
        blurQuality: document.getElementById('blurQualityValue'),
        trailDensity: document.getElementById('trailDensityValue'),
        evaporate: document.getElementById('evaporateValue'),
        refractBase: document.getElementById('refractBaseValue'),
        refractScale: document.getElementById('refractScaleValue')
      };
      
      // Update value displays
      function updateValueDisplay(control, display) {
        if (control.id === 'rainAmount') {
          display.textContent = `${control.value} drops`;
        } else if (control.id === 'rainSpeed') {
          display.textContent = `${control.value}x`;
        } else if (control.id === 'sizeVariance') {
          display.textContent = `${control.value}x`;
        } else if (control.id === 'windEffect') {
          display.textContent = control.value;
        } else if (control.id === 'trailIntensity') {
          display.textContent = control.value;
        } else if (control.id === 'blurQuality') {
          display.textContent = `${control.value} passes`;
        } else if (control.id === 'trailDensity') {
          display.textContent = control.value;
        } else if (control.id === 'evaporate') {
          display.textContent = control.value;
        } else if (control.id === 'refractBase') {
          display.textContent = control.value;
        } else if (control.id === 'refractScale') {
          display.textContent = control.value;
        }
      }
      
      // Apply control changes
      function applyControls() {
        // Update max drops
        rain.maxDrops = parseInt(controls.rainAmount.value);
        
        // Update gravity (speed)
        rain.gravityBase = 0.4 * parseFloat(controls.rainSpeed.value);
        
        // Update size variance (affects spawn radius range)
        rain.sizeVariance = parseFloat(controls.sizeVariance.value);
        
        // Update wind
        rain.windX = parseFloat(controls.windEffect.value);
        
        // Update trail intensity
        rain.trailIntensity = parseFloat(controls.trailIntensity.value);
        
        // Update blur quality
        rain.blurIterations = parseInt(controls.blurQuality.value);
        
        // Update advanced physics parameters
        rain.trailDropDensity = parseFloat(controls.trailDensity.value);
        rain.evaporate = parseFloat(controls.evaporate.value);
        rain.refractBase = parseFloat(controls.refractBase.value);
        rain.refractScale = parseFloat(controls.refractScale.value);
        
        // Update feature toggles
        rain.enableTrails = controls.enableTrails.checked;
        rain.enableCondensation = controls.enableCondensation.checked;
        rain.collisions = controls.enableCollisions.checked;
      }
      
      // Add event listeners
      Object.keys(controls).forEach(key => {
        const control = controls[key];
        if (control.type === 'range') {
          control.addEventListener('input', () => {
            updateValueDisplay(control, valueDisplays[key]);
            applyControls();
          });
        } else if (control.type === 'checkbox') {
          control.addEventListener('change', applyControls);
        } else if (control.tagName === 'BUTTON') {
          control.addEventListener('click', () => {
            if (key === 'playPauseBtn') {
              // Toggle play/pause
              if (rain.running) {
                rain.pause();
                control.innerHTML = '‚ñ∂Ô∏è Play Rain';
                control.style.background = '#ff6b6b';
              } else {
                rain.resume();
                control.innerHTML = '‚è∏Ô∏è Pause Rain';
                control.style.background = '#4dff87';
              }
            } else if (key === 'lightRain') {
              controls.rainAmount.value = 80;
              controls.rainSpeed.value = 0.3;
              controls.sizeVariance.value = 0.8;
              controls.windEffect.value = 0.02;
              controls.trailIntensity.value = 0.3;
              controls.blurQuality.value = 3;
            } else if (key === 'heavyRain') {
              controls.rainAmount.value = 200;
              controls.rainSpeed.value = 0.6;
              controls.sizeVariance.value = 1.2;
              controls.windEffect.value = 0.08;
              controls.trailIntensity.value = 0.7;
              controls.blurQuality.value = 5;
            } else if (key === 'storm') {
              controls.rainAmount.value = 300;
              controls.rainSpeed.value = 0.9;
              controls.sizeVariance.value = 1.5;
              controls.windEffect.value = 0.15;
              controls.trailIntensity.value = 0.9;
              controls.blurQuality.value = 6;
            }
            
            // Update displays and apply
            Object.keys(valueDisplays).forEach(displayKey => {
              updateValueDisplay(controls[displayKey], valueDisplays[displayKey]);
            });
            applyControls();
          });
        }
      });
      
      // Initialize displays
      Object.keys(valueDisplays).forEach(key => {
        updateValueDisplay(controls[key], valueDisplays[key]);
      });
    });
  })();
  </script>
</body>
</html>

