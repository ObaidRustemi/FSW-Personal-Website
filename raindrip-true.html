<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>True Raindrip - Refraction Not Glow</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif;
        }

        #rainCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        /* June's Control Panel */
        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .controls h3 {
            margin-bottom: 15px;
            color: #fff;
            font-size: 18px;
        }

        .controls button {
            display: block;
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .controls button:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-1px);
        }

        .stats {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
            font-size: 12px;
            color: rgba(255,255,255,0.8);
            font-family: monospace;
        }
    </style>
</head>
<body>
    <canvas id="rainCanvas"></canvas>

    <div class="controls">
        <h3>True Raindrip Controls</h3>
        <button onclick="rainSystem.toggleRain()">Toggle Rain</button>
        <button onclick="rainSystem.clearDrops()">Clear All</button>
        <button onclick="rainSystem.toggleDebug()">Toggle Debug</button>
        <button onclick="rainSystem.spawnBurst()">Spawn Burst</button>
        
        <div class="stats">
            <div>Drops: <span id="dropCount">0</span></div>
            <div>FPS: <span id="fps">60</span></div>
            <div>Merged: <span id="mergeCount">0</span></div>
        </div>
    </div>

    <script>
        // JUNE + JAY: TRUE RAINDRIP IMPLEMENTATION
        class RaindripSystem {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.drops = [];
                this.microDrops = []; // Surface speckle
                this.isRaining = false;
                this.debug = false;
                this.mergeCount = 0;
                
                // Performance
                this.dpr = Math.min(window.devicePixelRatio || 1, 2); // Cap at 2 for mobile
                this.lastTime = 0;
                this.fps = 60;
                
                // Offscreen canvases for dual-buffer approach
                this.bgSharp = document.createElement('canvas');
                this.bgBlur = document.createElement('canvas');
                this.bgSharpCtx = this.bgSharp.getContext('2d');
                this.bgBlurCtx = this.bgBlur.getContext('2d');
                
                this.init();
            }

            init() {
                this.resize();
                window.addEventListener('resize', () => this.resize());
                
                // Click to spawn
                this.canvas.addEventListener('click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = (e.clientX - rect.left) * this.dpr;
                    const y = (e.clientY - rect.top) * this.dpr;
                    this.spawnDrop(x, y, 15 + Math.random() * 25);
                });

                // Create background layers
                this.createBackground();
                
                // Start animation
                this.animate();
                
                // Auto-start rain
                setTimeout(() => this.toggleRain(), 500);
            }

            resize() {
                const w = window.innerWidth;
                const h = window.innerHeight;
                
                this.canvas.width = this.bgSharp.width = this.bgBlur.width = w * this.dpr;
                this.canvas.height = this.bgSharp.height = this.bgBlur.height = h * this.dpr;
                
                this.canvas.style.width = w + 'px';
                this.canvas.style.height = h + 'px';
                
                this.ctx.scale(this.dpr, this.dpr);
                
                // Recreate backgrounds on resize
                this.createBackground();
            }

            createBackground() {
                const w = this.bgSharp.width;
                const h = this.bgSharp.height;
                
                // SHARP BACKGROUND - High contrast night scene with lights
                this.bgSharpCtx.fillStyle = '#0a0a0a';
                this.bgSharpCtx.fillRect(0, 0, w, h);
                
                // City lights / bokeh effect
                const lights = 50;
                for (let i = 0; i < lights; i++) {
                    const x = Math.random() * w;
                    const y = Math.random() * h;
                    const r = 5 + Math.random() * 20;
                    const brightness = 0.3 + Math.random() * 0.7;
                    
                    const glow = this.bgSharpCtx.createRadialGradient(x, y, 0, x, y, r);
                    glow.addColorStop(0, `rgba(255,220,150,${brightness})`);
                    glow.addColorStop(0.3, `rgba(255,200,100,${brightness * 0.5})`);
                    glow.addColorStop(1, 'transparent');
                    
                    this.bgSharpCtx.fillStyle = glow;
                    this.bgSharpCtx.fillRect(x - r, y - r, r * 2, r * 2);
                }
                
                // Add some text that will refract nicely
                this.bgSharpCtx.save();
                this.bgSharpCtx.scale(this.dpr, this.dpr);
                this.bgSharpCtx.font = '72px SF Pro Display';
                this.bgSharpCtx.fillStyle = 'rgba(255,255,255,0.2)';
                this.bgSharpCtx.textAlign = 'center';
                this.bgSharpCtx.fillText('RAINDRIP', w / (2 * this.dpr), h / (2 * this.dpr));
                
                this.bgSharpCtx.font = '24px SF Pro Text';
                this.bgSharpCtx.fillStyle = 'rgba(255,255,255,0.15)';
                this.bgSharpCtx.fillText('slide to unlock', w / (2 * this.dpr), h / (2 * this.dpr) + 50);
                this.bgSharpCtx.restore();
                
                // BLUR BACKGROUND - Apply Gaussian blur
                this.bgBlurCtx.filter = 'blur(8px)';
                this.bgBlurCtx.drawImage(this.bgSharp, 0, 0);
                this.bgBlurCtx.filter = 'none';
            }

            spawnDrop(x, y, r) {
                // Log-normal size distribution
                const size = Math.exp(Math.random() * 1.5) * 5;
                
                this.drops.push({
                    x: x || Math.random() * this.canvas.width,
                    y: y || -50,
                    r: r || size,
                    vx: (Math.random() - 0.5) * 0.5, // Slight drift
                    vy: 0,
                    stretch: 1,
                    adhesion: 0.9 + Math.random() * 0.1, // Stickiness
                    age: 0
                });
            }

            spawnMicroDrop() {
                this.microDrops.push({
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    r: 0.5 + Math.random() * 1.5,
                    opacity: 0.1 + Math.random() * 0.2,
                    drift: (Math.random() - 0.5) * 0.1
                });
            }

            updateDrops(dt) {
                const gravity = 0.3;
                const maxDrops = 150;
                
                // Update main drops
                for (let i = this.drops.length - 1; i >= 0; i--) {
                    const d = this.drops[i];
                    
                    // Physics
                    d.vy += gravity * (d.r / 20); // Bigger drops fall faster
                    d.vy *= d.adhesion; // Sticky start
                    d.vx *= 0.98; // Air resistance
                    
                    // Stretch based on velocity
                    d.stretch = 1 + Math.min(d.vy / (10 * d.r), 1.2);
                    
                    // Update position
                    d.x += d.vx;
                    d.y += d.vy;
                    
                    // Age and adhesion
                    d.age++;
                    if (d.adhesion < 1) d.adhesion += 0.01;
                    
                    // Remove if off screen
                    if (d.y > this.canvas.height + d.r * 2) {
                        this.drops.splice(i, 1);
                    }
                }
                
                // Check for merges
                for (let i = 0; i < this.drops.length; i++) {
                    for (let j = i + 1; j < this.drops.length; j++) {
                        const d1 = this.drops[i];
                        const d2 = this.drops[j];
                        const dist = Math.hypot(d1.x - d2.x, d1.y - d2.y);
                        
                        if (dist < (d1.r + d2.r) * 0.8) {
                            // Merge! Conserve area
                            const newR = Math.sqrt(d1.r * d1.r + d2.r * d2.r);
                            d1.r = newR;
                            d1.x = (d1.x + d2.x) / 2;
                            d1.y = (d1.y + d2.y) / 2;
                            d1.vy = Math.max(d1.vy, d2.vy) * 1.1; // Boost on merge
                            d1.adhesion = 0.95; // Reset stickiness
                            
                            this.drops.splice(j, 1);
                            this.mergeCount++;
                            j--;
                        }
                    }
                }
                
                // Spawn new drops if raining
                if (this.isRaining && this.drops.length < maxDrops) {
                    if (Math.random() < 0.1) {
                        this.spawnDrop();
                    }
                }
                
                // Update micro drops
                for (let i = this.microDrops.length - 1; i >= 0; i--) {
                    const m = this.microDrops[i];
                    m.y += 0.1;
                    m.x += m.drift;
                    m.opacity *= 0.999;
                    
                    if (m.opacity < 0.01 || m.y > this.canvas.height) {
                        this.microDrops.splice(i, 1);
                    }
                }
                
                // Spawn micro drops occasionally
                if (Math.random() < 0.05 && this.microDrops.length < 100) {
                    this.spawnMicroDrop();
                }
            }

            render() {
                const ctx = this.ctx;
                
                // Clear and draw sharp background
                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                ctx.drawImage(this.bgSharp, 0, 0, this.canvas.width, this.canvas.height);
                
                // Draw micro drops (surface speckle)
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                for (const m of this.microDrops) {
                    ctx.globalAlpha = m.opacity;
                    ctx.beginPath();
                    ctx.arc(m.x / this.dpr, m.y / this.dpr, m.r / this.dpr, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
                
                // Draw main drops with refraction
                for (const d of this.drops) {
                    const x = d.x / this.dpr;
                    const y = d.y / this.dpr;
                    const rx = d.r * 0.92 / this.dpr;
                    const ry = d.r * 0.92 * d.stretch / this.dpr;
                    
                    // REFRACTION: Clipped blurred background with offset
                    ctx.save();
                    ctx.beginPath();
                    ctx.ellipse(x, y, rx, ry, 0, 0, Math.PI * 2);
                    ctx.clip();
                    
                    // Draw offset blurred background (the refraction effect!)
                    const offsetX = d.r * 0.25 / this.dpr;
                    const offsetY = -d.r * 0.15 / this.dpr;
                    ctx.drawImage(this.bgBlur, offsetX, offsetY, this.canvas.width, this.canvas.height);
                    ctx.restore();
                    
                    // Specular highlight
                    const highlightX = x - rx * 0.35;
                    const highlightY = y - ry * 0.35;
                    const highlight = ctx.createRadialGradient(
                        highlightX, highlightY, rx * 0.05,
                        x, y, rx
                    );
                    highlight.addColorStop(0, 'rgba(255,255,255,0.9)');
                    highlight.addColorStop(0.2, 'rgba(255,255,255,0.45)');
                    highlight.addColorStop(1, 'rgba(255,255,255,0)');
                    
                    ctx.fillStyle = highlight;
                    ctx.beginPath();
                    ctx.ellipse(x, y, rx, ry, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Rim lighting
                    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
                    ctx.lineWidth = Math.max(1, this.dpr) / this.dpr;
                    ctx.beginPath();
                    ctx.ellipse(x, y, rx, ry, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Streak effect for fast drops
                    if (d.vy > 8 * d.r / 20) {
                        ctx.globalAlpha = 0.2;
                        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                        ctx.lineWidth = rx * 0.3;
                        ctx.beginPath();
                        ctx.moveTo(x, y - ry * 0.8);
                        ctx.lineTo(x, y - ry * 3);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    }
                    
                    // Debug info
                    if (this.debug) {
                        ctx.fillStyle = 'lime';
                        ctx.font = '10px monospace';
                        ctx.fillText(`r:${d.r.toFixed(1)} v:${d.vy.toFixed(1)}`, x + rx, y);
                    }
                }
                
                // Update stats
                document.getElementById('dropCount').textContent = this.drops.length;
                document.getElementById('mergeCount').textContent = this.mergeCount;
            }

            animate(time = 0) {
                const dt = Math.min((time - this.lastTime) / 1000, 0.1);
                this.lastTime = time;
                
                // Calculate FPS
                if (dt > 0) {
                    this.fps = Math.round(1 / dt);
                    document.getElementById('fps').textContent = this.fps;
                }
                
                // Update and render
                this.updateDrops(dt);
                this.render();
                
                requestAnimationFrame((t) => this.animate(t));
            }

            toggleRain() {
                this.isRaining = !this.isRaining;
                if (this.isRaining) {
                    // Initial burst
                    for (let i = 0; i < 10; i++) {
                        setTimeout(() => this.spawnDrop(), i * 100);
                    }
                }
            }

            clearDrops() {
                this.drops = [];
                this.microDrops = [];
                this.mergeCount = 0;
            }

            toggleDebug() {
                this.debug = !this.debug;
            }

            spawnBurst() {
                for (let i = 0; i < 20; i++) {
                    const x = Math.random() * this.canvas.width;
                    const y = Math.random() * this.canvas.height * 0.5;
                    const r = Math.exp(Math.random() * 1.5) * 5;
                    this.spawnDrop(x, y, r);
                }
            }
        }

        // Initialize
        const canvas = document.getElementById('rainCanvas');
        const rainSystem = new RaindripSystem(canvas);
    </script>
</body>
</html>
